#version 450
layout(local_size_x = 16, local_size_y = 16) in;

#include "globalUbo.glsl"

layout(set = 1, binding = 0, rgba8) uniform image2D img;
layout(set = 1, binding = 1) uniform sampler2D depthImg;

#define MAX_STEPS 100
#define MAX_DIST 1000.0
#define SURFACE_DIST 0.001
#define INF 1e10

vec3 repeat(vec3 p, float c) {
    return mod(p, c) - 0.5 * c;
}

mat4 rotation3d(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat4(
        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,  0.0,
        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,  0.0,
        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c,           0.0,
        0.0,                                0.0,                               0.0,                               1.0
    );
}

vec3 rotate(vec3 v, vec3 axis, float angle) {
    mat4 m = rotation3d(axis, angle);
    return (m * vec4(v, 1.0)).xyz;
}

vec3 getColor(float t) {
    vec3 a = vec3(0.6, 0.4, 0.3);
    vec3 b = vec3(0.4, 0.3, 0.2);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.0, 0.10, 0.20);
    return a + b * cos(6.2831 * (c * t + d));
}

float smin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

float sdSphere(vec3 p, float radius) {
    return length(p) - radius;
}

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sdCross(vec3 p) {
    float da = sdBox(p.xyz, vec3(INF, 1.0, 1.0));
    float db = sdBox(p.yzx, vec3(1.0, INF, 1.0));
    float dc = sdBox(p.zxy, vec3(1.0, 1.0, INF));
    return min(da, min(db, dc));
}

vec3 twist(vec3 p) {
    float k = smoothstep(0.0, 0.2, ubo.time * 0.1);
    float c = cos(k * p.y);
    float s = sin(k * p.y);
    mat2 m = mat2(c, -s, s, c);
    p.xz = m * p.xz;
    return p;
}

float scene(vec3 p) {
    float spd = smoothstep(1.0, 6.0, ubo.time);
    float t = ubo.time * spd;
    vec3 p1 = rotate(p, vec3(1.0, 1.0, sin(t * 0.4)), t * 0.3);
    vec3 p2 = rotate(p1, vec3(1.0, 0.0, 0.0), 1.57);
    vec3 p3 = repeat(p, 4.0);

    float d = sdSphere(p1, 3.0);
    d = smin(sdCross(p1), d, 0.7);
    d = smin(sdTorus(p1, vec2(7.0, 1.0)), d, 0.7);
    d = smin(sdTorus(p2, vec2(7.0, 1.0)), d, 0.7);
    d = smin(sdSphere(p3, 0.5), d, 0.7);
    float scale = 1.0;
    for (int i = 0; i < 4; i++) {
        vec3 a = mod(p1 * scale, 2.0) - 1.0;
        scale *= 2.0;
        vec3 r = 1.0 - 3.0 * abs(a);
        float c = sdCross(r) / scale;
        d = max(d, c);
    }
    return d;
}

float raymarch(vec3 ro, vec3 rd) {
    float dO = 0.0;
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd * dO;
        float dS = scene(p);
        dO += dS;
        if (dO > MAX_DIST || dS < SURFACE_DIST) break;
    }
    return dO;
}

vec3 getNormal(vec3 p) {
    vec2 e = vec2(0.01, 0.0);
    vec3 n = vec3(
        scene(p + e.xyy) - scene(p - e.xyy),
        scene(p + e.yxy) - scene(p - e.yxy),
        scene(p + e.yyx) - scene(p - e.yyx));
    return normalize(n);
}

vec3 traceReflection(vec3 ro, vec3 rd) {
    float dist = raymarch(ro, rd);
    if (dist >= MAX_DIST) return vec3(0.0);
    vec3 p = ro + rd * dist;
    vec3 n = getNormal(p);
    vec3 baseColor = getColor(length(p) * 0.1);
    float diff = max(dot(n, normalize(vec3(5.0, 5.0, 15.0) - p)), 0.0);
    return baseColor * diff;
}

float extractNear() {
    float A = ubo.proj[2][2];
    float B = ubo.proj[3][2];
    return B / A;
}

float extractFar() {
    float A = ubo.proj[2][2];
    float B = ubo.proj[3][2];
    return B / (1.0 + A);
}

float delinearizeDepth(float dist) {
    float A = ubo.proj[2][2];
    float B = ubo.proj[3][2];
    return (B - A * dist) / (-dist);
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    // Boundary check
    if (texelCoord.x >= ubo.resolution.x || texelCoord.y >= ubo.resolution.y) return;

    vec2 normUv = texelCoord / ubo.resolution;
    vec2 uv = normUv * 2.0 - 1.0;
    uv.x *= ubo.aspectRatio;

    // Camera position from inverse view matrix
    vec3 ro = ubo.inverseView[3].xyz;

    // Compute ray direction to match projection matrix
    float tanHalfFov = 1.0 / ubo.proj[1][1]; // 1 / (1 / tan(fov/2)) = tan(fov/2)
    vec3 rd = normalize(vec3(uv.x * tanHalfFov * ubo.aspectRatio, uv.y * tanHalfFov, -1.0));

    // Read rasterized data
    vec4 rasterColor = imageLoad(img, texelCoord);
    float rasterDepth = texture(depthImg, normUv).r;
    
    // Raymarch
    float dist = raymarch(ro, rd);
    vec3 color = vec3(0.0);

    if (dist >= MAX_DIST) return;

    vec3 p = ro + rd * dist;
    vec3 normal = getNormal(p);
    color = getColor(length(p) * 0.1);
    float rim = pow(1.0 - max(dot(normal, -rd), 0.0), 2.0);
    color += rim * vec3(0.2, 0.3, 0.5);
    color = pow(color, vec3(1.0 / 2.2)); // Gamma correction
    float fogAmount = exp(-0.02 * dist);
    color = mix(vec3(0.3, 0.3, 0.4), color, fogAmount);

    float nonLinearRaymarchDepth = delinearizeDepth(dist);

    // Compare depths and write result
    if(nonLinearRaymarchDepth < rasterDepth) imageStore(img, texelCoord, vec4(color, 1.0));
    
}
