#version 450
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_EXT_scalar_block_layout : enable

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, scalar) buffer Data {
    vec2 data[];
} fftData;

layout(push_constant) uniform PushConstants {
    int N;     // FFT size
    int log2N; // log2(N)
    int mmax;  // Current stage size
    int mode;  // 0=rows, 1=columns
} pc;

const float PI = 3.141592653589793;

// Complex multiplication: (a + bi)(c + di) = (ac - bd) + (ad + bc)i
vec2 complexMul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;

    if (row >= pc.N || col >= pc.N) return;

    uint istep = uint(pc.mmax) * 2u;
    uint m = col % uint(pc.mmax);
    uint i = (col / uint(pc.mmax)) * istep + m;

    if (i >= pc.N) return;

    uint j = i + uint(pc.mmax);

    if (j >= pc.N) return;

    uint idx_i, idx_j;
    if (pc.mode == 0) {
        idx_i = row * uint(pc.N) + i;
        idx_j = row * uint(pc.N) + j;
    } else {
        idx_i = i * uint(pc.N) + col;
        idx_j = j * uint(pc.N) + col;
    }

    // Twiddle factor: e^(i * 2pi * m / istep)
    float theta = 2.0 * PI * float(m) / float(istep);
    vec2 w = vec2(cos(theta), sin(theta)); // Inverse FFT: +theta

    vec2 temp = complexMul(w, fftData.data[idx_j]);
    vec2 data_i = fftData.data[idx_i];

    fftData.data[idx_i] = data_i + temp;
    fftData.data[idx_j] = data_i - temp;
}
