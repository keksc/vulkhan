#version 450
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba32f) uniform writeonly image2D img;  // Output frequency texture

layout(push_constant) uniform PushConstants {
    float time;
} push;

#include "lygia/math/const.glsl"

const int N = 512;
const float L = 1000.0;
const float g = 9.81;
const float dk = (2.0 * PI) / L;

vec2 complexMultiply(vec2 a, vec2 b) {
    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
}

float jonswap(vec2 k) {
    float kLength = length(k);
    if (kLength < EPSILON) return 0.0;

    float omega = sqrt(g * kLength);
    float f = omega / (2.0 * PI);
    float f_m = 0.25;
    float sigma = (f <= f_m) ? 0.07 : 0.09;

    float b = exp(-pow((f/f_m - 1.0), 2.0) / (2.0 * pow(sigma, 2.0)));
    return 1.0 * pow(g, 2.0) / (16.0 * pow(PI, 4.0)) * 
           pow(f, -5.0) * exp(-5.0/4.0 * pow(f_m/f, 4.0)) * 
           pow(3.3, b);
}
vec2 hash2(vec2 p) {
    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
    return fract(sin(p) * 43758.5453);
}
void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    
    // Calculate wave vector components
    float kx = (float(gid.x) - N/2.0) * dk;
    float ky = (float(gid.y) - N/2.0) * dk;
    vec2 k = vec2(kx, ky);
    
    // Generate Gaussian random numbers with Box-Muller transform
    vec2 seed = hash2(gid);
    float theta = 2.0 * PI * seed.x;
    float r = sqrt(-2.0 * log(seed.y));
    vec2 xi = vec2(r * cos(theta), r * sin(theta));
    
    // Calculate JONSWAP spectrum
    float S = jonswap(k);
    
    // Create initial spectrum component
    vec2 H0 = xi * sqrt(S * dk * dk / 2.0);
    
    // Calculate dispersion relation
    float omega = sqrt(g * length(k));
    
    // Time evolution factors
    float phase = omega * push.time;
    vec2 exp_iwt = vec2(cos(phase), sin(phase));
    vec2 exp_neg_iwt = vec2(cos(phase), -sin(phase));
    
    // Calculate time-evolved spectrum
    vec2 H = complexMultiply(H0, exp_neg_iwt);
    
    // Store real and imaginary parts in output texture
    imageStore(img, gid, vec4(H, 0.0, 1.0));
}
